# Introduction

## Rappel sur les pointeurs

Un pointeur est une variable contenant l'adresse d'une autre variable d'un type donné. Il s'agit d'une technique de programmation très puissante, permettant de définir des structures dynamiques, c'est-à-dire qui évolue au cours du temps (par opposition aux tableaux par exemple qui sont des structures de données statiques, dont la taille est figée à la définition).

![Alt text](SmartPointer1?raw=true "Pointeur") 

## Des problèmes de désalocations 

Toute mémoire allouée dans vos programmes avec new doit être libérée à un moment ou un autre avec delete. Cette bonne règle de programmation peut vite devenir contraignante et parfois difficile à mettre en œuvre dans la pratique.

*Exemple de code pouvant poser problème :*

``` c++

#include <stdio.h>      /* printf */
#include <assert.h>     /* assert */

void Test1() 
{ 
    int * ptr = new int; 
    
    // ... du code
    
    // renvoi toujours une exception
    assert(false);
    
    // ... du code
    
    // tout s'est bien passé, libérer la mémoire
    // mais dans notre cas on ne passe pas par là
    // donc le pointeur n'est pas déférencé
    delete ptr; 
}
```
*Dans ce cas, on obtient une fuite mémoire car le pointeur n'est pas désaloué.*

*Pour solutionner le problème, il faudrait faire ce code :*

``` c++
// Test1 est exception safe sans utilisation de pointeur intelligent 
void Test1() 
{ 
    int * ptr = new int; 
    try 
    { 
       // ... du code
    
       assert(false); // renvoi toujours une exception
       
       // ... du code
    } 
    catch ( ... ) // gestion approximative... 
    { 
        // libérer le pointeur 
        delete ptr; 
        // relancer l'exception 
        throw; 
    } 
    
    // tout s'est bien passé, libérer la mémoire 
    delete ptr; 
}
```

Comme on peut le voir, cette gestion des exceptions est assez polémique, et surtout elle est totalement inélégante. Pensez qu'il faudrait procéder ainsi partout où il y a un new ! De plus, cette gestion peut rapidement être compliquée avec la complexité du code.

## Introduction des pointeurs intéligents

C'est pourquoi le C++ (depuis la version C++03) propose **des pointeurs "intéligent"** (smart pointers en anglais).

Les pointeurs intelligents sont des objets se comportant comme des pointeurs classiques (mimétisme dans la syntaxe et certaines sémantiques), mais qui offrent en plus des fonctionnalités intéressantes permettant une gestion quasi automatique de la mémoire (en particulier de sa libération). Leur syntaxe est très proche de celle des pointeurs classiques (grâce à la surcharge des opérateurs *, ->, etc.), mais ils utilisent en interne divers mécanismes (comptage de références) qui permettent de déceler qu'un objet n'est plus utilisé, auquel cas le pointeur intelligent se charge de le détruire ce qui permet d'éviter les fuites de mémoire.

Utiliser des pointeurs intelligents est généralement une très bonne idée, en particulier lors de l'écriture de code susceptible d'être interrompu par des exceptions (soit presque tout le temps !). Si tel est le cas, ceux-ci ne manqueront pas de libérer la mémoire qui leur est associée lors de leur destruction (suite à une exception ou non), ce qu'il n'est pas possible d'assurer sans multiplier les blocs try...catch dans son code.

Dans la STL, on trouve 3 types de pointeurs intéligent :

* std::auto_ptr<> *(C++03 - deprécié depuis C++11)* 
* std::unique_ptr<> *(C++11)*
* std::shared_ptr<> *(C++11)*

*Exemple de code avec un pointeur intéligent :*

``` c++
#include <memory> // pour std::unique_ptr 
  
// Test2 est exception safe en utilisant un pointeur intelligent 
void Test2() 
{ 

    // std::unique_ptr est la classe pointeur intelligent standard 
    std::unique_ptr<int> smart_ptr1 (new int()); 
    
    // autre façon de construire le pointeur (depuis C++11)
    std::unique_ptr<int> smart_ptr2 = std::make_unique<int>(); 
  
    // code pouvant lever une exception (rien d'autre !) 
    // pas de problème de fuite mémoire
}
```
La nouvelle version est tout aussi sûre, mais elle est bien plus triviale à mettre en place.

Cependant attention, les pointeurs intelligents n'échappent pas à la règle que ce qui a été alloué avec **new** doit être libéré avec **delete** et ce qui a été alloué avec new [] doit l'être avec delete []. L'intérêt des pointeurs intéligent provient de l'appel du delete du pointeur stocké par l'objet lors de sa destruction.


