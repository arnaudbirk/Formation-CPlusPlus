# Introduction

Toute mémoire allouée dans vos programmes avec new doit être libérée à un moment ou un autre avec delete. Cette bonne règle de programmation peut vite devenir contraignante et parfois difficile à mettre en œuvre dans la pratique.
Les pointeurs intelligents (smart pointers en anglais) sont des objets se comportant comme des pointeurs classiques (mimétisme dans la syntaxe et certaines sémantiques), mais qui offrent en plus des fonctionnalités intéressantes permettant une gestion quasi automatique de la mémoire (en particulier de sa libération). Leur syntaxe est très proche de celle des pointeurs classiques (grâce à la surcharge des opérateurs *, ->, etc.), mais ils utilisent en interne divers mécanismes (comptage de références) qui permettent de déceler qu'un objet n'est plus utilisé, auquel cas le pointeur intelligent se charge de le détruire ce qui permet d'éviter les fuites de mémoire.
Utiliser des pointeurs intelligents est généralement une très bonne idée, en particulier lors de l'écriture de code susceptible d'être interrompu par des exceptions (soit presque tout le temps !). Si tel est le cas, ceux-ci ne manqueront pas de libérer la mémoire qui leur est associée lors de leur destruction (suite à une exception ou non), ce qu'il n'est pas possible d'assurer sans multiplier les blocs try...catch dans son code.

*Exemple de code pouvant poser problème :*

``` c++
// Test1 est exception safe sans utilisation de pointeur intelligent 
void Test1() 
{ 
    int * ptr = new int; 
    try 
    { 
        // code pouvant lever une exception 
    } 
    catch ( ... ) // gestion approximative... 
    { 
        // libérer le pointeur 
        delete ptr; 
        // relancer l'exception 
        throw; 
    } 
    // tout s'est bien passé, libérer la mémoire 
    delete ptr; 
}
```

