# Quelques nouveauté du C++

Dans ce chapitre, nous alons recenser quelques nouveautés intéressantes apparues lors des mises à jour du langage

## C++11

### Délégation du constructeur

En C++03, un constructeur appartenant à une classe ne peut pas appeler un autre constructeur de cette même classe, ce qui peut entraîner de la duplication de code lors de l'initialisation de ses attributs. En permettant au constructeur de déléguer la création d'une instance à un autre constructeur, C++11 apporte donc une solution.

``` c++
    class une_classe {
        int nombre;

    public:
        une_classe(int nouveau_nombre) : nombre(nouveau_nombre) {}
        une_classe() : une_classe(42) {}
};
```
Dans l'exemple ci-dessus, on peut voir que le second constructeur appelle le premier constructeur, ce qui aurait conduit à une erreur de compilation en C++03.

### Héritage du constructeur

En C++03, les constructeurs d'une classe de base ne sont pas hérités par ses classes dérivées. C++11 permet d'hériter explicitement des constructeurs de la classe de base grâce à l'instruction using

``` c++
class classe_base {
public:
  classe_base(int nombre) : m_nombre(nombre)

private:
  int m_nombre;
};

class classe_derive : public classe_base {
public:
  using classe_base::classe_base;
};
```
### Initialiseurs d'attributs

En C++03, il est possible d'assigner une valeur par défaut aux variables statiques et constantes directement dans le fichier d'en-tête. C++11 étend cette possibilité aux attributs des classes. Par exemple il est désormais tout à fait possible d'écrire:

``` c++
class UneClasse {
public:
    UneClasse() {}
    explicit UneClasse(int valeur) : m_valeur(valeur) {}
    
private:
    int m_valeur = 5;
};
``` 
Dans ce code, tous les constructeurs de la classe vont initialiser m_valeur à 5, si le constructeur ne remplace pas l'initialisation avec la sienne. Par exemple, le constructeur vide ci-dessus va initialiser m_valeur selon la définition de la classe, mais le constructeur qui prend un int en paramètre initialisera m_valeur à ce paramètre. Il est également possible d'utiliser d'autres attributs dans l'initialisation, et d'utiliser un constructeur ou l'utilisation uniforme au lieu de l'initialisation par assignation.

### Les chevrons (<>)

Les compilateurs C++ actuels traitent toujours une séquence de deux signes supérieur à comme un opérateur de décalage binaire vers la droite. En conséquence, lors de l'imbrication de l'utilisation de patrons, les programmeurs sont obligés d'insérer un espace entre les deux chevrons fermants.

Par exemple, en C++03, ce code provoque une erreur de compilation :

``` c++
#include <vector>
std::vector<std::vector<int>> matrix;
// Attention ! Écrire plutôt : “std::vector<std::vector<int> >”
``` 
C++11 tentera de détecter automatiquement si les symboles doivent jouer le rôle de chevrons fermants ou d'opérateur de décalage binaire. En gros plus d'erreur de compilation.

### Inférence de types

#### auto

Le mot clef "auto" prend la place du type dans la déclaration. Le type sera est automatiquement décidé par correspondance avec le type retourné par l'objet utilisé pour l'initialisation de la variable. Les variables étant déclarées avec auto devront donc impérativement être initialisées. Exemple :

``` c++
auto f = boost::bind(MyFunc, _1);
f(5);
``` 

Le type de f est un type interne de la bibliothèque surchargé environ quatre-vingts fois avec un script Perl. Trouver le type exact pour stocker le résultat d'un bind dans un objet n'était pas pratique du tout avant le nouveau rôle du mot clé auto, d'où son apparition.

D'une manière générale, l'utilisation du mot clé auto permet de passer moins de temps à écrire ce que le compilateur sait déjà.

#### decltype

Le nouveau standard ajoute le mot clé decltype qui permet de typer une variable à partir du type d'une autre variable. Exemple:

``` c++
int i;
decltype(i) j = 5;
``` 

Le type de j sera du même type que i, soit int. Cette déclaration automatique du type d'une variable peut être très utile dans les templates.

### Les lambdas

Les lambda ont été introduit à partir du C++11. Voir le chapitre dédié.

### Boucles basées sur des intervalles

Le code nécessaire en C++ pour le parcours d'un intervalle et l'action sur ses éléments est répétitif et long. De nombreux langages, comme Java, ont fourni à leurs utilisateurs un opérateur foreach qui permet de parcourir une liste avec aisance6. Pour répondre aux attentes, la norme C++11 fournira une nouvelle syntaxe de l'instruction for qui s'implémentera de cette façon :

``` c++
int mon_tableau[5] = {1, 2, 3, 4, 5};
for (int &x: mon_tableau) {
    x *= 2;
}
``` 
Ce code permet de doubler tous les éléments du tableau mon_tableau. L'entier x défini pour le corps de la boucle for référence successivement chacun des éléments du tableau.

Ce type de parcours fonctionnera pour les listes classiques, les listes d'initialiseurs, ainsi que les conteneurs de la STL définissant les fonctions membres begin et end comme dans l'exemple suivant :

``` c++
std::vector<int> myvector;

myvector.push_back(100);
myvector.push_back(200);
myvector.push_back(300);

// Show content
std::cout << "\nShow content of " << myvector.size() << " elements\n";

std::cout << "Version with iterator\n";
for (std::vector<int>::iterator it = myvector.begin(); it != myvector.end(); ++it) {
    std::cout << *it << '\n';
}

std::cout << "Version with [] operator\n";
for (size_t n = 0; n < myvector.size(); ++n) {
    std::cout << myvector[n] << '\n';
}

std::cout << "Version 'foreach'\n";
for (int value: myvector) {      // for (auto value: myvector) est recommandé car aucune ambiguïté 
    std::cout << value << '\n';
}
``` 

### Threads

La bibliothèque standard a implémenté dans la nouvelle norme du C++, le modèle de classe std::thread, celui-ci n'est qu'une implémentation des threads de la bibliothèque Boost. 

Voir le chapitre relatif au thread.

### Tuple

Un tuple est une collection de dimension fixe d'objets de types différents. 

``` c++
template <class... Types> class tuple;
``` 

Un exemple de définition et d'utilisation du type tuple :

``` c++
typedef tuple< int, double, long &, const char * > test_tuple ;
long lengthy = 12 ;
test_tuple proof( 18, 6.5, lengthy, "Ciao!" ) ;
lengthy = get<0>(proof) ;  // Assigne à ‘lengthy’ la valeur 18
get<3>(proof) = " Beautiful!" ;  // Modifie la {{4e}} valeur du tuple
``` 

Il est possible de créer le tuple proof sans définir son contenu si les éléments du tuple possèdent un constructeur par défaut. 

De plus, il est possible d'assigner un tuple à un autre tuple : si les deux tuples sont de même type, il est nécessaire que chaque élément du tuple ait un constructeur par copie, sinon il faut que le type de chaque élément de l'opérande de droite soit compatible avec le type correspondant dans l'opérande de gauche ou que l'élément correspondant de l'opérande gauche ait un constructeur approprié.

``` c++
typedef tuple< int , double, string       > tuple_1 t1 ;
typedef tuple< char, short , const char * > tuple_2 t2( 'X', 2, "Hola!" ) ;
t1 = t2 ;  // OK : les deux premiers éléments peuvent être convertis,
           // le troisième peut être construit à partir du ‘const char *’.
``` 

### Fonctions mathématiques spéciales

En plus des fonctions mathématiques classique présentent dans le C++03, le C++11 introduit de nouvelles fonctions mathématiques. En voici quelques-une :
* Polynômes de Laguerre généralisés
* Polynômes de Legendre généralisés
* Fonction bêta
* Intégrale elliptique complète de premier et deuxième genre
* Fonctions de Bessel (*)
* Intégrale exponentielle
* Polynômes de Laguerre
* Polynômes de Legendre
* Fonction zêta de Riemann
* ...

## C++14


## C++17


