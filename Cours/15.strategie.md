# Pattern Strategie

* Problème :
  * Un traitement dans une classe peut être implémenté par divers algorithmes (certains étant plus efficaces, moins consommateurs de mémoire, etc.)
  * Choisir le bon algorithme par des instructions conditionnelles n'est pas satisfaisant
  * Il est utile de pouvoir permuter dynamiquement les algorithmes utilisés dans une application.

* Description :
Le patron stratégie est prévu pour fournir des moyens de définir une famille d'algorithmes, encapsuler chacun comme objet, et les rendre interchangeables. Le patron stratégie laisse les algorithmes changer
indépendamment des clients qui les emploient.

## Structure

![Pattern Strategy](pattern_strategy.png)

## Exemple

On veut créer une classe SortedList modélisant une liste de chaînes de caractères pouvant être triée
par différents algorithmes (tri fusion, tri rapide, etc.). Une première solution pourrait consister à créer une
méthode sort() directement dans la classe SortedList , permettant d'appliquer un traitement en fonction d'un paramètre en entrée (avec un switch ou des instructions conditionnelles):

``` c++
class SortedList {
    private:
        std::vector<std::string> list;
        std::string sortType;
    
    public:
        SortedList(std::string sortType) {
            this.sortType = sortType;
        }

        void add (std::string s) {
            this.add(s);
            this.sort();
        }

        void sort(){
            if ( this.sortType == "QuickSort" ) {
                this.quicksort();
            }
            else if (this.sortType == "MergeSort" ) {
                this.mergesort ();
            }
        }

        private:
            void quickSort () {
            // Application de l'algorithme tri rapide
            }
            void mergesort () {
            // Application de l'algorithme tri fusion
            }
}
```

Mais ajouter un nouvel algorithme de tri violerait alors le principe SOLID celui d'ouverture/fermeture : il faudrait modifier le code de la méthode ```sort()``` De plus, si les algorithmes ont des paramètres spécifiques, il faudra ajouter des attributs sur la classe SortedList.
Implementer directement les algorithmes de tris dans la classe ```SortedList``` ne respecte pas le principe de
responsabilité unique : la classe va à la fois gérer la liste (ajout d'éléments, parcours, etc.) et les algorithmes
de tris.

Exemple avec le pattern stratégie :

``` c++
/*
* L'interface permetant d ' encapsuler et d ' externaliser les algo de tris
*/
class SortStrategy {
    public:
        virtual void sort (std::vector<std::string> list)=0;
}

/*
* Première réalisation donc premier algo de tri
*/
class QuickSort:SortStrategy {

    public:
        void sort (List<String> list ) {
        // Application de l ' algorithme tri rapide
        }
}

/*
* Seconde réalisation donc premier algo de tri
*/
class MergeSort implements SortStrategy {

    public:
        void sort (std::vector <std::string> list) {
        // Application de l ' algorithme tri fusion
        }
}

/*
* Classe utilisatrice du pattern Strategy
*/
class SortedList{
    private:
        std::vector<std::string> list;
        SortStrategy sortStrategy;
    public:
        SortedList (String sortType){
             this.sortType = sortType;
        }

        void add (String s) {
            this.add (s);
            this.sort();
        }

        void setSortStrategy (SortStrategy s) {
            this.sortStrategy = s;
        }

        void sort () {
            this.sortStrategy.sort(this.list);
        }
}
```

[Exercice Pattern Strategy](../Exercices/Exerice21/README.md)
